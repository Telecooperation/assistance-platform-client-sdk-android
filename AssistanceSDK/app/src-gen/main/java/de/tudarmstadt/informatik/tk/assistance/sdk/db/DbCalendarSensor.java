package de.tudarmstadt.informatik.tk.assistance.sdk.db;

import org.greenrobot.greendao.annotation.*;

import de.tudarmstadt.informatik.tk.assistance.sdk.db.DaoSession;
import org.greenrobot.greendao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit.
/**
 * Entity mapped to table "calendar_sensor".
 */
@Entity(active = true, nameInDb = "calendar_sensor")
public class DbCalendarSensor implements de.tudarmstadt.informatik.tk.assistance.sdk.interfaces.IDbUpdatableSensor {

    @Id(autoincrement = true)
    @Index
    private Long id;
    private Long eventId;
    private Long calendarId;
    private Boolean allDay;
    private Integer availability;
    private String description;
    private Long timestampStart;
    private Long timestampEnd;
    private String duration;
    private String location;
    private String timezoneStart;
    private String timezoneEnd;
    private String recurrenceExceptionDate;
    private String recurrenceExceptionRule;
    private Boolean hasAlarm;
    private Long lastDate;
    private Boolean originalAllDay;
    private String originalId;
    private Long originalInstanceTime;
    private String recurrenceDate;
    private String recurrenceRule;
    private Integer status;
    private String title;
    private Boolean isNew;
    private Boolean isUpdated;
    private Boolean isDeleted;

    @NotNull
    private String created;

    @Index
    private Long deviceId;

    /** Used to resolve relations */
    @Generated
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    @Generated
    private transient DbCalendarSensorDao myDao;

    @ToOne(joinProperty = "deviceId")
    private DbDevice dbDevice;

    @Generated
    private transient Long dbDevice__resolvedKey;

    @Generated
    public DbCalendarSensor() {
    }

    public DbCalendarSensor(Long id) {
        this.id = id;
    }

    @Generated
    public DbCalendarSensor(Long id, Long eventId, Long calendarId, Boolean allDay, Integer availability, String description, Long timestampStart, Long timestampEnd, String duration, String location, String timezoneStart, String timezoneEnd, String recurrenceExceptionDate, String recurrenceExceptionRule, Boolean hasAlarm, Long lastDate, Boolean originalAllDay, String originalId, Long originalInstanceTime, String recurrenceDate, String recurrenceRule, Integer status, String title, Boolean isNew, Boolean isUpdated, Boolean isDeleted, String created, Long deviceId) {
        this.id = id;
        this.eventId = eventId;
        this.calendarId = calendarId;
        this.allDay = allDay;
        this.availability = availability;
        this.description = description;
        this.timestampStart = timestampStart;
        this.timestampEnd = timestampEnd;
        this.duration = duration;
        this.location = location;
        this.timezoneStart = timezoneStart;
        this.timezoneEnd = timezoneEnd;
        this.recurrenceExceptionDate = recurrenceExceptionDate;
        this.recurrenceExceptionRule = recurrenceExceptionRule;
        this.hasAlarm = hasAlarm;
        this.lastDate = lastDate;
        this.originalAllDay = originalAllDay;
        this.originalId = originalId;
        this.originalInstanceTime = originalInstanceTime;
        this.recurrenceDate = recurrenceDate;
        this.recurrenceRule = recurrenceRule;
        this.status = status;
        this.title = title;
        this.isNew = isNew;
        this.isUpdated = isUpdated;
        this.isDeleted = isDeleted;
        this.created = created;
        this.deviceId = deviceId;
    }

    /** called by internal mechanisms, do not call yourself. */
    @Generated
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getDbCalendarSensorDao() : null;
    }

    @Override
    public Long getId() {
        return id;
    }

    @Override
    public void setId(Long id) {
        this.id = id;
    }

    public Long getEventId() {
        return eventId;
    }

    public void setEventId(Long eventId) {
        this.eventId = eventId;
    }

    public Long getCalendarId() {
        return calendarId;
    }

    public void setCalendarId(Long calendarId) {
        this.calendarId = calendarId;
    }

    public Boolean getAllDay() {
        return allDay;
    }

    public void setAllDay(Boolean allDay) {
        this.allDay = allDay;
    }

    public Integer getAvailability() {
        return availability;
    }

    public void setAvailability(Integer availability) {
        this.availability = availability;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Long getTimestampStart() {
        return timestampStart;
    }

    public void setTimestampStart(Long timestampStart) {
        this.timestampStart = timestampStart;
    }

    public Long getTimestampEnd() {
        return timestampEnd;
    }

    public void setTimestampEnd(Long timestampEnd) {
        this.timestampEnd = timestampEnd;
    }

    public String getDuration() {
        return duration;
    }

    public void setDuration(String duration) {
        this.duration = duration;
    }

    public String getLocation() {
        return location;
    }

    public void setLocation(String location) {
        this.location = location;
    }

    public String getTimezoneStart() {
        return timezoneStart;
    }

    public void setTimezoneStart(String timezoneStart) {
        this.timezoneStart = timezoneStart;
    }

    public String getTimezoneEnd() {
        return timezoneEnd;
    }

    public void setTimezoneEnd(String timezoneEnd) {
        this.timezoneEnd = timezoneEnd;
    }

    public String getRecurrenceExceptionDate() {
        return recurrenceExceptionDate;
    }

    public void setRecurrenceExceptionDate(String recurrenceExceptionDate) {
        this.recurrenceExceptionDate = recurrenceExceptionDate;
    }

    public String getRecurrenceExceptionRule() {
        return recurrenceExceptionRule;
    }

    public void setRecurrenceExceptionRule(String recurrenceExceptionRule) {
        this.recurrenceExceptionRule = recurrenceExceptionRule;
    }

    public Boolean getHasAlarm() {
        return hasAlarm;
    }

    public void setHasAlarm(Boolean hasAlarm) {
        this.hasAlarm = hasAlarm;
    }

    public Long getLastDate() {
        return lastDate;
    }

    public void setLastDate(Long lastDate) {
        this.lastDate = lastDate;
    }

    public Boolean getOriginalAllDay() {
        return originalAllDay;
    }

    public void setOriginalAllDay(Boolean originalAllDay) {
        this.originalAllDay = originalAllDay;
    }

    public String getOriginalId() {
        return originalId;
    }

    public void setOriginalId(String originalId) {
        this.originalId = originalId;
    }

    public Long getOriginalInstanceTime() {
        return originalInstanceTime;
    }

    public void setOriginalInstanceTime(Long originalInstanceTime) {
        this.originalInstanceTime = originalInstanceTime;
    }

    public String getRecurrenceDate() {
        return recurrenceDate;
    }

    public void setRecurrenceDate(String recurrenceDate) {
        this.recurrenceDate = recurrenceDate;
    }

    public String getRecurrenceRule() {
        return recurrenceRule;
    }

    public void setRecurrenceRule(String recurrenceRule) {
        this.recurrenceRule = recurrenceRule;
    }

    public Integer getStatus() {
        return status;
    }

    public void setStatus(Integer status) {
        this.status = status;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    @Override
    public Boolean getIsNew() {
        return isNew;
    }

    @Override
    public void setIsNew(Boolean isNew) {
        this.isNew = isNew;
    }

    @Override
    public Boolean getIsUpdated() {
        return isUpdated;
    }

    @Override
    public void setIsUpdated(Boolean isUpdated) {
        this.isUpdated = isUpdated;
    }

    @Override
    public Boolean getIsDeleted() {
        return isDeleted;
    }

    @Override
    public void setIsDeleted(Boolean isDeleted) {
        this.isDeleted = isDeleted;
    }

    @Override
    @NotNull
    public String getCreated() {
        return created;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    @Override
    public void setCreated(@NotNull String created) {
        this.created = created;
    }

    public Long getDeviceId() {
        return deviceId;
    }

    public void setDeviceId(Long deviceId) {
        this.deviceId = deviceId;
    }

    /** To-one relationship, resolved on first access. */
    @Generated
    public DbDevice getDbDevice() {
        Long __key = this.deviceId;
        if (dbDevice__resolvedKey == null || !dbDevice__resolvedKey.equals(__key)) {
            __throwIfDetached();
            DbDeviceDao targetDao = daoSession.getDbDeviceDao();
            DbDevice dbDeviceNew = targetDao.load(__key);
            synchronized (this) {
                dbDevice = dbDeviceNew;
            	dbDevice__resolvedKey = __key;
            }
        }
        return dbDevice;
    }

    @Generated
    public void setDbDevice(DbDevice dbDevice) {
        synchronized (this) {
            this.dbDevice = dbDevice;
            deviceId = dbDevice == null ? null : dbDevice.getId();
            dbDevice__resolvedKey = deviceId;
        }
    }

    /**
    * Convenient call for {@link org.greenrobot.greendao.AbstractDao#delete(Object)}.
    * Entity must attached to an entity context.
    */
    @Generated
    public void delete() {
        __throwIfDetached();
        myDao.delete(this);
    }

    /**
    * Convenient call for {@link org.greenrobot.greendao.AbstractDao#update(Object)}.
    * Entity must attached to an entity context.
    */
    @Generated
    public void update() {
        __throwIfDetached();
        myDao.update(this);
    }

    /**
    * Convenient call for {@link org.greenrobot.greendao.AbstractDao#refresh(Object)}.
    * Entity must attached to an entity context.
    */
    @Generated
    public void refresh() {
        __throwIfDetached();
        myDao.refresh(this);
    }

    @Generated
    private void __throwIfDetached() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }
    }

}
